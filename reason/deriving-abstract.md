`deriving-abstract` is one of the two ways how to define JavaScript object (the
other one is hash map).  
`deriving-abstract` is used when:

- you have known and fixed set of fields and
- might or might not contain values of different types

```reason
[@bs.deriving abstract]
type displaySizeT = {
  width: int,
  height: int,
};
```

`displaySizeT` is not a record, it's a record-looking type that uses the
record's syntax and type-checking. The `bs.deriving abstract` annotation turns
it into an "abstract type" (you don't know what the actual value's shape).

**Creation**  
Since `bs.deriving abstract` turns the `displaySizeT` record into an abstract
type, you can't directly create a person record as you would usually. This
doesn't work: `{width: 10, height: 10}`.

Instead, you'd use the creation function of the same name as the record type,
implicitly generated by the `bs.deriving abstract` annotation:

```reason
let displaySize = displaySizeT(~width=10, ~height=10);
```

Output:

```reason
let displaySize = {width: 20, heigh: 10}
```

**Optional labels**

```reason
[@bs.deriving abstract]
type displaySizeT = {
  [bs.optional] size: int,
  width: int,
  height: int,
};
```

`[bs.optional]` turned the `size` field optional. So, you can omit it during the
object creation.

When your creation function contains optional fields, you need to always use the
unit symbol - `()` - to indicate that we've finished applying the function. You
need to do this since functions in Reason are curried by default and also the
arguments could be applied out-of-order. So, if we pass only the required
fields, compiler would return a new function since it'll think, we might pass
the remaining arguments later. However, when we pass unlabelled `()` at the end,
the compiler will presume the optional labeled argument is omitted.

```reason
let displaySize = displaySizeT(~width=10, ~height=10, ());
```

**Accessors**  
Since `bs.deriving abstract` hides the actual record shape, you can't access a
field using e.g. `displaySize.age`. We remediate this by generating getter and
setters.

Read:  
One getter function is generated per `bs.deriving abstract` record type field.
In the above example, you'd get 3 functions: `widthGet`, `heightGet`, `sizeGet`.

```reason
let size = sizeGet(displaySize);
```

or, alternatively using a `Fast pipe`

```reason
let size = displaySize->sizeSet
```

Write:  
A `bs.deriving abstract` value is immutable by default. To mutate such value,
you need to first mark one of the abstract record fields as mutable, the same
way you'd mark a normal record as mutable

```reason
[@bs.deriving abstract]
type displaySizeT = {
  mutable size: int,
  width: int,
  height: int,
};
```

Then, a setter of the name `sizeSet` will be generated.

```reason
let displaySize = displaySizeT(~size= 20, ~width=10, ~height=10);

sizeSet(displaySize, 30);
```

or, alternatively

```reason
displaySize |. sizeSet(30)
```

[source](https://bucklescript.github.io/docs/en/object)
